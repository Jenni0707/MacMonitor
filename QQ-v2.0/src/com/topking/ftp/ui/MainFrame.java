package com.topking.ftp.ui;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;

import javax.swing.*;

import sun.net.TelnetInputStream;
import sun.net.ftp.FtpClient;

import com.topking.ftp.bean.DownLoadBean;
import com.topking.ftp.bean.FileBean;
import com.topking.ftp.bean.UpLoadBean;
import com.topking.ftp.util.DownLoadFromRemote;
import com.topking.ftp.util.UpLoadToRemote;
import com.topking.swingui.MyJTable;
import com.topking.swingui.install.InstallData;
import com.topking.swingui.renderer.MyListCellRenderer;

/**
 * MainFrame ftp处理总类
 * 
 * @author
 */

public class MainFrame extends JFrame implements ActionListener, Observer {
	/**
	 * serialVersionUID
	 */
	private static final long serialVersionUID = 1L;
	/** Creates new form NewJFrame */
	// Variables declaration - do not modify
	private JTextField T_local;// 本地
	private JTextField T_remote;// 远程
	private JButton bt_browser;// 浏览
	private JButton bt_localreturn;// 本地返回按钮
	private JButton bt_remotereturn;// 服务器端返回按钮
	private JScrollPane jScrollPane1;// 本地滚动条
	private JScrollPane jScrollPane2;// 服务器滚动条
	private JScrollPane jScrollPane3;// 进度条的滚动条
	private JList list_local;// 本地列表
	public JList list_remote;// 远程列表
	public MyJTable tb_progress;// 百分比进度条
	private String[] title;
	private Vector<InstallData> installs;// 设置容器用于添加进度条的信息
	public FtpClient ftp;// 一切上传下载操作就指望他的
	// private String currentDir;// 现在的目录
	private String localPath;// 本地路径
	public String remotePath; // 远程路径
	private DateFormat df;// 日期
	public static String LOCpath[] = new String[2];
	private JPopupMenu Lpop;// 本地快捷菜单
	private JMenuItem Lrename;// 本地重命名
	private JMenuItem Lload;// 本地更新
	private JMenuItem Ldelete;// 本地删除
	private JMenuItem Lproperty;// 本地属性
	private JMenuItem Lupload;// 本地上传
	// 右键功能设置
	private JPopupMenu Rpop;
	private JMenuItem Rrename;
	private JMenuItem Rdelete;
	private JMenuItem Rproperty;
	private JMenuItem Rdownload;
	private JMenuItem Rload;

	private int Rx = 0;
	private int Ry = 0;
	private int Lx = 0;
	private int Ly = 0;
	public int RowCount = 0;// 定义一个用于返回当前单元格所处行的参数

	TelnetInputStream inStream = null;

	private List<UpLoadBean> upList;// 上传列表
	private List<DownLoadBean> downList;// 下载列表

	// 初始化mainframe
	public MainFrame(FtpClient ftp) {
		this.ftp = ftp;
		this.setTitle("FTP工具 FOR Mac");
		this.setIconImage(this.getToolkit().createImage(
				this.getClass().getClassLoader()
						.getResource("com/topking/ftp/ui/images/ftplogo.gif")));
		// this.setExtendedState(JFrame.MAXIMIZED_BOTH);
		Toolkit kit = Toolkit.getDefaultToolkit();
		this.setLocation((kit.getScreenSize().width - 800) / 2,
				(kit.getScreenSize().height - 600) / 2);
		initAll();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initAll() {
		localPath = LOCpath[0];
		remotePath = "/";
		df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		upList = new ArrayList<UpLoadBean>(); //
		downList = new ArrayList<DownLoadBean>();
		initComponents(); // 构造组件
		loadLocalFile(); // 导入本地文件
		loadRemoteFile();// 导入远程文件
		refreshLocalPath();// 更新本地路径
		refreshRemotePath();// 更新远程路径
		// new Thread(new removeTB()).start();//创建一个新线程并运行****他是卡的罪魁祸首
	}

	private void initComponents() {

		title = new String[] { "文件名", "大小", "进度", "速度", "状态" };
		installs = new Vector<InstallData>();
		InstallData data_name = new InstallData("文件名", new ImageIcon(this
				.getClass().getClassLoader()
				.getResource("com/topking/ftp/ui/images/name.gif")));
		InstallData data_sex = new InstallData("大小", new ImageIcon(this
				.getClass().getClassLoader()
				.getResource("com/topking/ftp/ui/images/size.gif")));
		InstallData data_brith = new InstallData("进度", new ImageIcon(this
				.getClass().getClassLoader()
				.getResource("com/topking/ftp/ui/images/progress.gif")));
		InstallData data_phone = new InstallData("速度", new ImageIcon(this
				.getClass().getClassLoader()
				.getResource("com/topking/ftp/ui/images/speed.gif")));
		InstallData data_address = new InstallData("状态", new ImageIcon(this
				.getClass().getClassLoader()
				.getResource("com/topking/ftp/ui/images/state.gif")));

		installs.add(data_name);
		installs.add(data_sex);
		installs.add(data_brith);
		installs.add(data_phone);
		installs.add(data_address);

		bt_browser = new JButton();
		T_local = new JTextField();
		bt_localreturn = new JButton();
		bt_remotereturn = new JButton();
		T_remote = new JTextField();
		jScrollPane1 = new JScrollPane();
		list_local = new JList();
		jScrollPane2 = new JScrollPane();
		list_remote = new JList();
		jScrollPane3 = new JScrollPane();
		tb_progress = new MyJTable(title, installs);

		Lpop = new JPopupMenu();
		Lrename = new JMenuItem("重命名");
		Ldelete = new JMenuItem("删除");
		Lload = new JMenuItem("刷新");
		Lproperty = new JMenuItem("属性");
		Lupload = new JMenuItem("上传");

		bt_browser.addActionListener(this);

		Lproperty.addActionListener(this);
		Lload.addActionListener(this);
		Lrename.addActionListener(this);
		Ldelete.addActionListener(this);
		Lupload.addActionListener(this);
		Lpop.add(Lproperty);
		Lpop.add(Lload);
		Lpop.add(Lupload);
		Lpop.add(Lrename);
		Lpop.add(Ldelete);
		list_local.add(Lpop);

		Rpop = new JPopupMenu();
		Rrename = new JMenuItem("重命名");
		Rload = new JMenuItem("刷新");
		Rdelete = new JMenuItem("删除");
		Rproperty = new JMenuItem("属性");
		Rdownload = new JMenuItem("下载");

		Rproperty.addActionListener(this);
		Rdownload.addActionListener(this);
		Rrename.addActionListener(this);
		Rdelete.addActionListener(this);
		Rload.addActionListener(this);

		Rpop.add(Rproperty);
		Rpop.add(Rload);
		Rpop.add(Rdownload);
		Rpop.add(Rrename);
		Rpop.add(Rdelete);
		list_remote.add(Rpop);
		// 在list_local增加鼠标功能
		list_local.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				if (list_local.getLastVisibleIndex() == -1)
					return;
				// InstallData d = (InstallData)list_local.getSelectedValue();
				// FileBean fb = (FileBean)d.getValue();
				// System.err.println(fb.getType()+";"+fb.getSize()+";"+fb.getTime());
				if (e.getClickCount() == 2) {
					InstallData data = (InstallData) list_local
							.getSelectedValue();
					// System.out.println(data.getText());
					if (!isFile(localPath + "/" + data.getText())) {
						localPath = localPath + "/" + data.getText() + "/";
						refreshLocalPath();
						loadLocalFile();
						JWindow jw = new JWindow(MainFrame.this);
						jw.add(new JLabel("hello"));
						jw.setVisible(true);
					} else {
						openFile(localPath + "/" + data.getText());
					}
				}// end if
					// 设置list_local菜单的位置
				if (e.getButton() == 3) {
					Lpop.show(list_local, e.getX(), e.getY());
					Lx = 0;
					Ly = 0;
					Lx = e.getX() + 10;
					Ly = e.getY() + 10;
				}
			}
		});
		// 在list_remote中增加鼠标双击相应的功能
		list_remote.addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				if (list_remote.getLastVisibleIndex() == -1)
					return;
				// InstallData d = (InstallData)list_remote.getSelectedValue();
				// FileBean fb = (FileBean)d.getValue();
				// System.err.println(fb.getType()+";"+fb.getSize()+";"+fb.getTime());
				if (e.getClickCount() == 2) {
					InstallData data = (InstallData) list_remote
							.getSelectedValue();
					if (isDir(data.getText(), remotePath, ftp)) {// 文件夹
						if (ftp.serverIsOpen()) {
							try {
								ftp.cd(remotePath + data.getText().trim() + "/");
								remotePath = remotePath + data.getText().trim()
										+ "/";
								System.out.println("remotePath+data.getText: "
										+ remotePath);
								refreshRemotePath();
								loadRemoteFile();
							} catch (IOException e1) {
								e1.printStackTrace();
							}
						} else {
							JOptionPane.showMessageDialog(MainFrame.this,
									"服务器已经关闭，操作失败", "错误",
									JOptionPane.ERROR_MESSAGE);
						}
					} // end if
				}// end if
				if (e.getButton() == 3) {
					Rpop.show(list_remote, e.getX(), e.getY());
					Ry = 0;
					Rx = e.getX() + 400;
					Ry = e.getY() + 10;
				}
			}
		});

		T_local.addActionListener(this);
		T_remote.addActionListener(this);
		bt_localreturn.addActionListener(this);
		bt_remotereturn.addActionListener(this);

		// setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

		bt_browser.setText("浏览");
		bt_localreturn.setText("返回");
		bt_remotereturn.setText("返回");

		jScrollPane1.setViewportView(list_local);
		jScrollPane2.setViewportView(list_remote);
		jScrollPane3.setViewportView(tb_progress);
		// 设置滚动条：包括水平垂直，总共6个
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(
				getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(
						javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup()
								.addComponent(bt_browser).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addComponent(T_local,javax.swing.GroupLayout.DEFAULT_SIZE,343,Short.MAX_VALUE)
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(bt_localreturn))
								.addComponent(jScrollPane1,javax.swing.GroupLayout.DEFAULT_SIZE,469, Short.MAX_VALUE))
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
										.addGroup(layout.createSequentialGroup().addComponent(bt_remotereturn)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addComponent(T_remote,javax.swing.GroupLayout.DEFAULT_SIZE,384,Short.MAX_VALUE))
												.addComponent(jScrollPane2,javax.swing.GroupLayout.DEFAULT_SIZE,447, Short.MAX_VALUE)))
												.addComponent(jScrollPane3,javax.swing.GroupLayout.Alignment.TRAILING,
														javax.swing.GroupLayout.DEFAULT_SIZE, 922,Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(
						javax.swing.GroupLayout.Alignment.BASELINE).addComponent(bt_browser)
						.addComponent(T_remote,javax.swing.GroupLayout.PREFERRED_SIZE,
								javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE)
								.addComponent(bt_remotereturn).addComponent(bt_localreturn)
								.addComponent(T_local,javax.swing.GroupLayout.PREFERRED_SIZE,
										javax.swing.GroupLayout.DEFAULT_SIZE,javax.swing.GroupLayout.PREFERRED_SIZE))
										.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
												.addComponent(jScrollPane1,javax.swing.GroupLayout.DEFAULT_SIZE,433, Short.MAX_VALUE)
												.addComponent(jScrollPane2,javax.swing.GroupLayout.DEFAULT_SIZE,433, Short.MAX_VALUE))
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addComponent(jScrollPane3,javax.swing.GroupLayout.PREFERRED_SIZE,139,javax.swing.GroupLayout.PREFERRED_SIZE)));
		clearInfo();
		pack();

	}// </editor-fold>

	// 上传完成后清理tb_progress里的信息
	public void clearInfo() {
		int RowCount = tb_progress.getRowCount();
		for (int i = 0; i < RowCount; i++) {
			((javax.swing.table.DefaultTableModel) (tb_progress.getModel()))
					.removeRow(0);
			tb_progress.updateUI();
		}
		for (int i = 0; i < upList.size(); i++) {
			upList.remove(i);
		}
		for (int i = 0; i < downList.size(); i++) {
			downList.remove(i);
		}
		RowCount = 0;
		loadRemoteFile();
	}

	// 给出openfile函数体，实现打开文件功能
	public void openFile(String file) {
		String[] cmd = new String[3];
		cmd[0] = "cmd";
		cmd[1] = "/C";
		cmd[2] = file;
		try {
			Runtime.getRuntime().exec(cmd);// 调用其它函数
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// 给出loadlocalfile函数体
	public void loadLocalFile() {
		if (localPath != null && !"".equals(localPath)) {
			Vector<InstallData> v = new Vector<InstallData>();
			System.out.println("------" + localPath);
			String[] files = new File(localPath).list();
			if (files.length != 0) {
				for (int i = 0; i < files.length; i++) {
					InstallData data;
					FileBean fb = new FileBean();
					File file = new File(localPath + "/" + files[i]);
					fb.setFileName(file.getName());
					// fb.setFilePath(file.getAbsolutePath());
					fb.setSize(file.length());
					fb.setTime(df.format(new Date(file.lastModified())));
					if (isFile(localPath + "/" + files[i])) {// 文件
						fb.setType("文件");
						fb.setFilePath(file.getAbsolutePath());
						data = new InstallData(files[i], new ImageIcon(this
								.getClass().getClassLoader().getResource(
										"com/topking/ftp/ui/images/file.gif")),fb);

					} else {// 文件夹
						fb.setType("文件夹");
						fb.setFilePath(file.getAbsolutePath());
						data = new InstallData(files[i],
								new ImageIcon(this.getClass().getClassLoader()
										.getResource("com/topking/ftp/ui/images/folder.gif")),fb);
					}
					v.add(data);
					list_local.setModel(new DefaultComboBoxModel(v));
					list_local.setCellRenderer(new MyListCellRenderer());
					refreshLocalPath();
				}
			} else {
				list_local.removeAll();
				list_local.setModel(new DefaultComboBoxModel());
				list_local.setCellRenderer(new MyListCellRenderer());
				refreshLocalPath();
			}
		}
	}

	// 给出listRemoteFile函数体，实现远程目录刷新
	public String listRemoteFile(String path, FtpClient ftp) {
		String list = null;
		try {
			ftp.cd(path);
			TelnetInputStream is = ftp.list();
			int c;
			StringBuffer sb = new StringBuffer();
			while ((c = is.read()) != -1) {
				sb.append((char) c);
			}
			is.close();
			String list2 = new String(sb);
			list = new String(list2.getBytes("iso8859-1"), "UTF-8");
		} catch (UnsupportedEncodingException e) {
			System.err.println("字符编码错误 MainFrame.listRemoteFile:"
					+ e.getMessage());
		} catch (IOException e) {
			System.err.println("Error:刷新远程目录失败 异常信息: " + e.getMessage());
			// e.printStackTrace();
			return null;
		}
		return list;
	}

	// 给出loadRemoteFile函数体
	public void loadRemoteFile() {
		String list = listRemoteFile(remotePath, ftp);
		if (list == null || list.equals("")) {
			list_remote.removeAll();
			list_remote.setModel(new DefaultComboBoxModel());
			list_remote.setCellRenderer(new MyListCellRenderer());
			refreshRemotePath();
			return;
		}
		System.out.println("loadRemoteFilelist:\n" + list);
		String[] info = list.split("\n");
		Vector<InstallData> v = new Vector<InstallData>();

		for (int i = 0; i < info.length; i++) {
			InstallData data;
			// System.err.println("info[" + i + "] " + info[i]);
			if (info[i].length() > 8) {
				info[i] = info[i].replaceAll(" ", "/");
				while (info[i].contains("//")) {
					info[i] = info[i].replaceAll("//", "/");
				}
				String[] s = info[i].split("/");
				String fname = s[s.length - 1].trim();
				if (!fname.startsWith(".") && !fname.startsWith("..")) {
					FileBean fb = new FileBean();
					String time = s[5] + " " + s[6] + " " + s[7];
					fb.setFileName(fname);
					fb.setTime(time);
					fb.setSize(Long.parseLong(s[4]));
					String type = s[0];
					if (type.contains("drw")) {// 文件夹
						fb.setType("文件夹");
						fb.setFilePath(remotePath + fname + "/");
						data = new InstallData(
								fname,
								new ImageIcon(
										this.getClass()
												.getClassLoader()
												.getResource(
														"com/topking/ftp/ui/images/folder.gif")),
								fb);
					} else {// 文件
						fb.setType("文件");
						fb.setFilePath(remotePath + fname);
						data = new InstallData(fname, new ImageIcon(this
								.getClass()
								.getClassLoader()
								.getResource(
										"com/topking/ftp/ui/images/file.gif")),
								fb);
					}
					v.add(data);
					list_remote.setModel(new DefaultComboBoxModel(v));
					list_remote.setCellRenderer(new MyListCellRenderer());
					refreshRemotePath();
				}
			}
		}
	}

	public void refreshLocalPath() {
		T_local.setText(localPath);
	}

	public String getRemotePath() {
		return T_remote.getText().trim();
	}

	public void refreshRemotePath() {
		T_remote.setText(remotePath);
	}

	public String getLocalPath() {
		return T_local.getText().trim();
	}

	// 根据不同操作给出响应
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == bt_browser) {// 浏览
			JFileChooser jfc = new JFileChooser();
			jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			jfc.showOpenDialog(this);
			String path = jfc.getSelectedFile().getPath();
			if (path.length() != 3) {
				while (path.contains("\\")) {
					path = path.replaceAll("\\\\", "//");
				}
				path = path.concat("/");
			} else
				path = path.replaceAll("\\\\", "/");
			localPath = path;
			refreshLocalPath();
			loadLocalFile();
		}

		if (e.getSource() == bt_localreturn) {// 本地返回
			System.out.println("localPath=" + localPath);
			if (localPath.contains("//")) {
				String[] paths = localPath.split("//");
				StringBuffer newPath = new StringBuffer();
				newPath.append(paths[0]);
				if (paths.length > 2) {
					for (int i = 0; i < paths.length - 2; i++) {
						newPath.append("//" + paths[i + 1]);
					}
				}
				newPath.append("/");
				localPath = new String(newPath);
			}
			System.out.println("localPath=" + localPath);
			refreshLocalPath();
			loadLocalFile();
		}

		if (e.getSource() == bt_remotereturn) {
			if ("/".equals(T_remote.getText())) {
				T_remote.setText("/");
				remotePath = "/";
			} else {
				String[] paths = remotePath.split("/");
				StringBuffer newPath = new StringBuffer();
				for (int i = 0; i < paths.length - 1; i++) {
					newPath.append(paths[i] + "/");
				}
				remotePath = new String(newPath);
			}
			refreshRemotePath();
			loadRemoteFile();
		}

		if (e.getSource() == T_local) {
			if (T_local.getText().trim() != null
					&& !"".equals(T_local.getText().trim())) {
				localPath = T_local.getText().trim().replace('\\', '/');
				refreshLocalPath();
				loadLocalFile();
			}
		}

		if (e.getSource() == T_remote) {
			if (T_remote.getText().trim() != null
					&& !"".equals(T_remote.getText().trim())) {
				remotePath = T_remote.getText().trim();
				refreshRemotePath();
				loadRemoteFile();
			}
		}

		if (e.getSource() == Lrename) {
			InstallData d = (InstallData) list_local.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				ReNameFrame ref = new ReNameFrame(fb, Lx, Ly, "LOCAL", null);
				ref.addObserver(this);
			}
		}

		if (e.getSource() == Ldelete) {
			InstallData d = (InstallData) list_local.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				int result = JOptionPane
						.showOptionDialog(
								this,
								fb.getType().equals("文件夹") ? "是否确定删除文件夹:"
										+ fb.getFileName() : "是否确定删除文件:"
										+ fb.getFileName(), "删除文件",
								JOptionPane.YES_NO_OPTION,
								JOptionPane.DEFAULT_OPTION, null, new Object[] {
										"是", "否" }, JOptionPane.YES_OPTION);
				if (result == 0) {
					if (fb.getType().equals("文件夹")) {
						delAllLocalFile(fb.getFilePath());
					} else
						delFile(fb.getFilePath());
					loadLocalFile();
				}
			}
		}

		if (e.getSource() == Lproperty) {
			InstallData d = (InstallData) list_local.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				new PropertyWindow(fb, Lx, Ly).setVisible(true);
			}
		}

		// ************************上传********************************
		if (e.getSource() == Lupload) {
			InstallData d = (InstallData) list_local.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				System.out.println("上传fb=" + fb.getFileName());
				/**
				 * clear the list;
				 * */
				for (int i = 0; i < upList.size(); i++) {
					upList.remove(i);
				}

				System.out.println("RemotePath : " + remotePath);
				// new Thread(new upLoadToRemote(remotePath, fb.getFilePath(),
				// ftp)).start();
				new Thread(new UpLoadToRemote(this, remotePath,
						fb.getFilePath(), ftp)).start();
			}
		}

		// *************下载**********************************************
		if (e.getSource() == Rdownload) {
			InstallData d = (InstallData) list_remote.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				System.out.println("下载fb=" + fb.getFileName());
				/**
				 * clear the list;
				 * */
				for (int i = 0; i < downList.size(); i++) {
					downList.remove(i);
				}
				System.out.println("本地路径 : " + localPath);
				System.out.println("fb.getFileName() : " + fb.getFileName());
				System.out.println("fb.getFilePath() : " + fb.getFilePath());
				System.out.println("fb.getSize() : " + fb.getSize());
				// fdl.download(fb.getFilePath(),localPath,fb,ftp);
				Thread dlfr = new Thread(new DownLoadFromRemote(this,
						fb.getFilePath(), localPath, fb, ftp));
				dlfr.start();
			}
		}

		if (e.getSource() == Rrename) {
			InstallData d = (InstallData) list_remote.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				ReNameFrame rf = new ReNameFrame(fb, Rx, Ry, "REMOTE", ftp);
				rf.addObserver(this);
			}
		}

		if (e.getSource() == Rdelete) {
			InstallData d = (InstallData) list_remote.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				int result = JOptionPane
						.showOptionDialog(
								this,
								fb.getType().equals("文件夹") ? "是否确定删除文件夹:"
										+ fb.getFileName() : "是否确定删除文件:"
										+ fb.getFileName(), "删除文件",
								JOptionPane.YES_NO_OPTION,
								JOptionPane.DEFAULT_OPTION, null, new Object[] {
										"是", "否" }, JOptionPane.YES_OPTION);
				if (result == 0) {
					if (fb.getType().equals("文件夹")) {
						if (deleteDirectory(fb.getFilePath(), true)) {
							loadRemoteFile();
							return;
						} else {
							JOptionPane.showMessageDialog(this, "删除文件失败 异常信息("
									+ ")", "错误", JOptionPane.ERROR_MESSAGE);
						}
					} else {
						if (deleteFile(fb.getFilePath())) {
							loadRemoteFile();
							return;
						} else {
							JOptionPane.showMessageDialog(this, "删除文件失败 异常信息("
									+ ")", "错误", JOptionPane.ERROR_MESSAGE);
						}
					}
				}
			}
		}

		if (e.getSource() == Rproperty) {
			InstallData d = (InstallData) list_remote.getSelectedValue();
			if (d != null) {
				FileBean fb = (FileBean) d.getValue();
				new PropertyWindow(fb, Rx, Ry).setVisible(true);
			}
		}
		if (e.getSource() == Rload) {
			loadRemoteFile();
		}
		if (e.getSource() == Lload) {
			loadLocalFile();
		}
	}

	public void decrypt(String srcFile) {
		String PWD = System.getProperty("user.dir");
		System.out.println("PWD: " + PWD);
		String projectName = System.getProperty("java.class.path");
		System.out.println("Java类路径： " + projectName);
		String decryptFilePath = "\\decrypt.exe";
		// if (PWD.endsWith(projectName)) {
		// decryptFilePath = PWD.replaceFirst(projectName, "blowfish-c.exe");
		// }
		if (PWD == null || PWD.isEmpty()) {
			return;
		}
		decryptFilePath = PWD + decryptFilePath;
		System.out.println("decryptFilePath: " + decryptFilePath+"----");
		String enccmd[] = new String[3];

		String desFile;
		if (srcFile.endsWith("EN")) {
			desFile = srcFile + ".jpg";
		} else {
			desFile = srcFile + ".txt";
		}

		// enccmd[0] = "E:\\WorkSpace\\blowfish-c.exe" + " " + srcFile + " " +
		// desFile;
		enccmd[0] = "\""+decryptFilePath+"\"" + " " +"\""+srcFile+"\"" + " " + "\""+desFile+"\"";
		enccmd[1] = "cmd /c del" + " " + "\""+srcFile+"\"";
		System.out.println(enccmd[0]);

		Runtime run = Runtime.getRuntime(); // 返回与当前 Java 应用程序相关的运行时对象
		try {
			Process p = run.exec(enccmd[0]); // 启动解密进程
			BufferedInputStream in = new BufferedInputStream(p.getInputStream());
			BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
			String lineStr;
			while ((lineStr = inBr.readLine()) != null)
				// 获得命令执行后在控制台的输出信息
				System.out.println(lineStr);// 打印输出信息
			inBr.close();
			in.close();
			// 检查命令是否执行失败。
			if (p.waitFor() != 0) {
				if (p.exitValue() == 1)// p.exitValue()==0表示正常结束，1：非正常结束
					System.err.println("解密命令执行失败!");
				return;
			}
			if (desFile.contains("keydeflog.txt")) {
				MacToWindows(desFile);
			}
			Process p1 = Runtime.getRuntime().exec(enccmd[1]); // 启动删除进程
			if (p1.waitFor() != 0) {
				if (p1.exitValue() == 1)// p.exitValue()==0表示正常结束，1：非正常结束
					System.err.println("解密命令执行失败1!");
			}
		} catch (Exception exp) {
			System.err.println("错误：解密文件失败！！！" + exp.getMessage());
		}
	}

	// 判断是否运行结束
	public class removeTB implements Runnable {
		boolean canBeClear = true;

		public void run() {
			Label: while (ftp.serverIsOpen()) {
				System.out.println(upList);
				if (upList != null && upList.size() > 0 && downList.size() > 0) {// 所有线程已经执行完毕
					for (int i = 0; i < tb_progress.getRowCount(); i++) {
						if (!"上传完毕".equals(tb_progress.getModel().getValueAt(i,
								4))) {
							continue Label;
						}// end if
						clearInfo();
					} // end if
				} // end while
			} // end run
		}
	}

	public void update(Observable o, Object arg) {
		if (arg instanceof String) { // 更新
			String temp = (String) arg;
			System.out.println(arg);
			if (temp.equals("LOCAL_RENAME_OK")) {
				loadLocalFile();
			}
			if (temp.equals("REMOTE_RENAME_OK")) {
				loadRemoteFile();
			}
			if (temp.equals("DOWNLOAD_FINISH")) {
				loadLocalFile();
			}
		}
	}

	// 对键盘记录进行windows下可读处理
	public boolean MacToWindows(String fileName) {
		File file = new File(fileName);
		FileInputStream fis;
		try {
			fis = new FileInputStream(file);
			byte[] b1=new byte[fis.available()];
			fis.read(b1);
			System.out.println("以行为单位读取文件内容，一次读一整行：");
			byte[] tempbyte = new byte[b1.length];
			int j=0;
			// 一次读入一行，直到读入null为文件结束
			for(int i=0;i<b1.length;i++){
				if((b1[i]!=0x00)){
					if(b1[i]==0x0a){
						tempbyte[j++] = '\r';
						tempbyte[j++] = '\n';
					}else
						tempbyte[j++]=b1[i];
				}
			}
			fis.close();
			// 重新写回到keydeflog.txt文件中
			FileOutputStream out=new FileOutputStream(file);
			out.write(tempbyte);
			out.flush();
			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		} 
		return true;
	}

	// 创建本地文件夹
	public boolean createLocalDir(String dir) {
		boolean flag = true;
		if (!isExistDir(dir)) {
			if (!(new File(dir).mkdir())) {
				flag = false;
			}
		}
		return flag;
	}

	// 创建远程文件夹
	public boolean createRemoteDir(String Rpath, String fileName, FtpClient ftp) {
		boolean flag = false;
		if (!isExsitDir(Rpath + fileName, ftp)) {
			try {
				String cmd = "MKD " + Rpath + fileName + "/" + "\r\n";
				System.err.println("createRemoteDir CMD : " + cmd);
				ftp.sendServer(cmd);
				ftp.binary();
				int reply = ftp.readServerResponse();
				System.err.println("createRemoteDir Reply : " + reply);
				flag = true;
			} catch (IOException e) {
				System.err.println("错误：创建远程文件夹失败！！！");
			}
		}
		return flag;
	}

	// 判断本地文件夹是否存在
	public boolean isExistDir(String dir) {
		boolean flag = false;
		if (new File(dir).exists()) {
			flag = true;
		}
		return flag;
	}

	// 判断远程文件夹是否存在
	public boolean isExsitDir(String dir, FtpClient ftpClient) {
		try {
			ftpClient.cd(dir);
		} catch (IOException e) {
			System.err.println("文件夹不存在.......................");
			return false;
		}
		return true;
	}

	// 判断本地路径是文件还是文件夹
	public boolean isFile(String fname) {
		File file = new File(fname);
		return file.isDirectory() ? false : true;
	}

	// 判断远程ftp路径是文件还是文件夹
	public boolean isDir(String fname, String dir, FtpClient ftpClient) {
		try {
			ftpClient.cd(dir);
			System.out.println("FileupdataUtil.listFile");
			TelnetInputStream is = ftpClient.list();
			int c, i = 0;
			StringBuffer sb = new StringBuffer();
			while ((c = is.read()) != -1) {
				// sb.append((char) c);
				if (c == 10 || c == 13) {
					sb.append('\n');
				} else {
					sb.append((char) c);
				}
			}
			is.close();
			String list1 = new String(sb);
			// String list2 = new String(list1);
			String list2 = new String(list1.getBytes("ISO-8859-1"), "UTF-8");
			String[] liststr = list2.split("\n");
			for (i = 0; i < liststr.length; i++) {
				if ((liststr[i].contains(fname))
						&& (liststr[i].contains("drw"))) {
					System.out
							.println("FileupdataUtil.listFile\n" + liststr[i]);
					return true;
				}
			}
		} catch (UnsupportedEncodingException e) {
			System.err.println("字符编码错误 MainFrame.isDir:" + e.getMessage());
			// e.printStackTrace();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, "FTP已断开，请重新登陆", "warning",
					JOptionPane.ERROR_MESSAGE);
			System.err.println("error in isDir!!" + e.getMessage());
			// e.printStackTrace();
		}
		return false;
	}

	/**
	 * 删除文件
	 */
	public void delFile(String filePathAndName) {
		try {
			String filePath = filePathAndName;
			filePath = filePath.toString();
			File myDelFile = new File(filePath);
			myDelFile.delete();
			System.out.println("删除文件操作 成功执行");
		} catch (Exception e) {
			System.out.println("删除文件操作出错");
			e.printStackTrace();

		}

	}

	/**
	 * 删除本地文件夹
	 */
	public void delLocalFolder(String folderPath) {
		try {
			String filePath = folderPath;
			filePath = filePath.toString();
			File myFilePath = new File(filePath);
			myFilePath.delete(); // 删除空文件夹
			System.out.println("删除文件夹操作 成功执行");
		} catch (Exception e) {
			System.out.println("删除文件夹操作出错");
			// e.printStackTrace();
		}
	}

	/**
	 * 删除本地文件夹里面的所有文件
	 * 
	 * @param path
	 *            String 文件夹路径 如 c:/fqf
	 */
	public void delAllLocalFile(String path) {
		File file = new File(path);
		if (!file.exists()) {
			return;
		}
		if (!file.isDirectory()) {
			return;
		}
		String[] tempList = file.list();
		File temp = null;
		for (int i = 0; i < tempList.length; i++) {
			if (path.endsWith(File.separator)) {
				temp = new File(path + tempList[i]);
			} else {
				temp = new File(path + File.separator + tempList[i]);
			}
			if (temp.isFile()) {
				temp.delete();
			}
			if (temp.isDirectory()) {
				delAllLocalFile(path + "/" + tempList[i]);// 先删除文件夹里面的文件
				delLocalFolder(path + "/" + tempList[i]);// 再删除空文件夹
			}
		}
		delLocalFolder(path);// 再删除空文件夹
		System.err.println("删除文件操作 成功执行");
	}

	/**
	 * 删除FTP上的文件
	 * 
	 * @param ftpDirAndFileName
	 */
	public boolean deleteFile(String ftpDirAndFileName) {
		if (!ftp.serverIsOpen())
			return false;
		try {
			String fileName = ftpDirAndFileName;
			if (fileName.endsWith("/")) {
				fileName = fileName.substring(0, fileName.length() - 1);
			}
			String cmd = "DELE " + fileName.trim() + "\r\n";
			System.out.println(cmd);
			ftp.sendServer(cmd);
			ftp.binary();
			int reply = ftp.readServerResponse();// 等待返回结果
			if (reply == 200) {
				// JOptionPane.showMessageDialog(this, "文件已经删除");
				return true;
			}
		} catch (FileNotFoundException e) {
			JOptionPane.showMessageDialog(this,
					"删除FTP文件失败 异常信息(" + e.getMessage() + ")", "错误",
					JOptionPane.ERROR_MESSAGE);
			return false;
		} catch (IOException e1) {
			JOptionPane.showMessageDialog(this,
					"删除FTP文件失败 异常信息(" + e1.getMessage() + ")", "错误",
					JOptionPane.ERROR_MESSAGE);
			return false;
		}
		return true;
	}

	/**
	 * 删除FTP目录
	 * 
	 * @param ftpDirectory
	 */
	public boolean deleteDirectory(String ftpDirectory) {
		if (!ftp.serverIsOpen())
			return false;
		try {
			String cmd = "rmd " + ftpDirectory + "\r\n";
			// String cmd = "XRMD "+ ftpDirectory +"\r\n";
			System.out.println(cmd);
			ftp.sendServer(cmd);
			ftp.binary();
			int reply = ftp.readServerResponse();// 等待返回结果
			if (reply == 200) {
				// JOptionPane.showMessageDialog(this, "文件夹已经删除!");
				return true;
			}
		} catch (FileNotFoundException e) {
			JOptionPane.showMessageDialog(this,
					"删除FTP文件夹失败 异常信息(" + e.getMessage() + ")", "错误",
					JOptionPane.ERROR_MESSAGE);
			return false;
		} catch (IOException e1) {
			JOptionPane.showMessageDialog(this,
					"删除FTP文件夹失败 异常信息(" + e1.getMessage() + ")", "错误",
					JOptionPane.ERROR_MESSAGE);
			return false;
		}
		return true;
	}

	/**
	 * 删除FTP目录
	 * 
	 * @param ftpDirectory
	 */
	public boolean deleteDirectory(String ftpDirectory, boolean isAll) {
		if (!ftpDirectory.endsWith("/")) {
			ftpDirectory = ftpDirectory + "/";
		}
		if (!isAll) {
			return deleteDirectory(ftpDirectory);
		}
		String list = listRemoteFile(ftpDirectory, ftp);
		if ((list == null) || (list.equals(""))) {
			return deleteDirectory(ftpDirectory);
		}
		String[] info = list.split("\n");
		for (int i = 0; i < info.length; i++) {
			info[i] = info[i].replaceAll(" ", "/");
			while (info[i].contains("//")) {
				info[i] = info[i].replaceAll("//", "/");
			}
			String[] s = info[i].split("/");
			String fname = s[s.length - 1].trim();
			if (fname.equals(".") || fname.startsWith("..")) {
				continue;
			}
			String type = s[0];
			if (type.contains("drw")) {// 文件夹
				deleteDirectory(ftpDirectory + fname, true);
			} else {
				deleteFile(ftpDirectory + fname);
			}
		}
		return deleteDirectory(ftpDirectory);
	}
}
